use bytes::BytesMut;
use nom::IResult;

use crate::protocol::header::{
    parse_identifier, parse_length, parse_message, parse_opcode, parse_version,
};

#[derive(Debug)]
pub struct Header {
    /// Protocol version and direction of frame (request/response)
    pub version: u8,
    /// `u8` opcode that maps to a known command
    pub opcode: u8,
    /// `u16` field to determine length of the body
    pub length: u16,
    /// `u64` randomly generated bytes that are used as a unique identifier
    pub identifier: u64,
}

impl Header {
    pub fn parse(src: &mut BytesMut) -> IResult<&[u8], Header> {
        let (i, version) = parse_version(src)?;
        let (i, opcode) = parse_opcode(i)?;
        let (i, length) = parse_length(i)?;
        let (i, identifier) = parse_identifier(i)?;
        let (_, message) = parse_message(i, length.into())?;

        println!("message: {:?}", message);

        let header = Header {
            version,
            opcode,
            length,
            identifier,
        };

        Ok((message, header))
    }
}

/// The protocol version, coupled with the direction of the frame.
///
/// The "direction" of the frame indicates whether the frame is a `Request` or
/// a `Response` variant. This will help keep track of traffic flow later.
#[derive(Debug, PartialEq)]
pub enum Version {
    Request,
    Response,
}

#[derive(Debug)]
pub struct Identifier {
    inner: [u8; 8],
}

impl Identifier {
    /// Constructs a new `Identifier` by generating a random array of bytes.
    pub fn new() -> Self {
        Self { inner: [0u8; 8] }
    }

    /// Get a reference to the inner data
    pub fn as_bytes(&self) -> &[u8] {
        &self.inner
    }
}

impl Default for Identifier {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug)]
pub struct Message {
    /// Variable length payload determined by the `length_field` value
    pub body: BytesMut,
}

#[cfg(test)]
mod tests {
    use bytes::BufMut;
    use rand::{thread_rng, RngCore};

    use super::*;

    fn generate_identifier() -> [u8; 8] {
        let mut identifier = [0u8; 8];
        thread_rng().fill_bytes(&mut identifier[..]);
        identifier
    }

    #[test]
    fn header_can_be_decoded() {
        // Setup
        let mut buf = BytesMut::with_capacity(24);

        let data = b"\x01\x02\x00\x00";
        buf.reserve(data.len());
        buf.put(&data[..]);

        let identifier = generate_identifier();
        buf.put(&identifier[..]);

        // Parse data from `Bytes` buffer into header while reading it into `dst`
        let (message, header) = Header::parse(&mut buf).unwrap();

        assert_eq!(header.version, 1);
        assert_eq!(header.opcode, 2);
        assert_eq!(header.length, 0);
        assert!(message.is_empty());
    }

    // #[test]
    // fn random_nonce_is_correctly_parsed() {
    //     let data = b"\x01\x02\x00\x0C\x63\x6F\x6E\x64\x75\x69\x74\x33";
    //
    //     let mut dst = BytesMut::with_capacity(8);
    //     dst.reserve(data.len());
    //     thread_rng().fill_bytes(&mut dst);
    //
    //     let (i, nonce) = parse_identifier(&dst).expect("failed to decode nonce");
    //
    //     assert_ne!(nonce, 0);
    // }
}
