use bytes::{Buf, BufMut, Bytes, BytesMut};
use rand::{thread_rng, RngCore};

use crate::opcode::Opcode;

pub const MAX_FRAME_LEN: usize = 65536;
pub const HEADER_LEN: usize = 4;
pub const NONCE_LEN: usize = 8;

// FIXME: Finish Frame logic and write header / message parser

#[derive(Debug)]
pub struct Frame {
    #[allow(dead_code)]
    header: Header,
    #[allow(dead_code)]
    message: Message,
}

#[derive(Debug)]
pub struct Header {
    /// Protocol version and direction of frame (request/response)
    pub version: u8,
    /// `u8` opcode that maps to a known command
    pub opcode: u8,
    /// `u16` field to determine length of the body
    pub length: u16,
    /// `u64` randomly generated bytes that are used as a unique identifier
    pub nonce: Bytes,
}

impl Header {
    pub fn new(mut data: BytesMut) -> Header {
        let version = data.get_u8();
        let opcode = data.get_u8();
        let length = data.get_u16();
        let nonce = Bytes::copy_from_slice(&data.get_u64().to_be_bytes());
        Header {
            version,
            opcode,
            length,
            nonce,
        }
    }

    pub fn version(&self) -> u8 {
        self.version
    }

    pub fn opcode(&self) -> (u8, Opcode) {
        let kind = Opcode::kind(self.opcode);
        (self.opcode, kind)
    }

    pub fn length(&self) -> u16 {
        self.length
    }

    pub fn nonce(&self) -> Bytes {
        Bytes::copy_from_slice(&self.nonce[..])
    }

    pub fn into_bytes(&self) -> Bytes {
        let mut buf = BytesMut::with_capacity(12);
        buf.put_u8(self.version());
        buf.put_u8(self.opcode().0);
        buf.put_u16(self.length());
        buf.put_slice(&self.nonce()[..]);
        buf.freeze()
    }
}

/// The protocol version, coupled with the direction of the frame.
///
/// The "direction" of the frame indicates whether the frame is a `Request` or
/// a `Response` variant. This will help keep track of traffic flow later.
#[derive(Debug)]
pub enum Version {
    Request,
    Response,
}

#[derive(Debug)]
pub struct Nonce(Bytes);

impl Nonce {
    /// Constructs a new `Nonce` by generating a random array of bytes.
    pub fn new() -> Self {
        let mut dst = [0_u8; 8];
        thread_rng().fill_bytes(&mut dst);
        Self(Bytes::copy_from_slice(&dst))
    }

    /// Get a reference to the inner data
    pub fn as_bytes(&self) -> &Bytes {
        &self.0
    }

    /// Get a reference to the inner data
    pub fn into_inner(self) -> Bytes {
        self.0
    }
}

impl Default for Nonce {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug)]
pub struct Message {
    /// Variable length payload determined by the `length_field` value
    pub body: BytesMut,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn header_can_be_decoded() {
        // Setup
        let data = b"\x01\x02\x00\x0C\x63\x6F\x6E\x64\x75\x69\x74\x33";
        let mut buf = BytesMut::with_capacity(12);

        buf.put_slice(data);
        // Parse data from `Bytes` buffer into header while reading it into `dst`
        let header = Header::new(buf);

        assert_eq!(header.into_bytes().len(), 12);
        assert!(!header.into_bytes().is_empty());
        println!("header contents test passed:\n{header:X?}");
    }
}
