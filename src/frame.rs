use bytes::BytesMut;
use nom::IResult;
use rand::{thread_rng, RngCore};

use crate::protocol::header::{parse_length, parse_nonce, parse_opcode, parse_version};

#[derive(Debug)]
pub struct Header {
    /// Protocol version and direction of frame (request/response)
    pub version: u8,
    /// `u8` opcode that maps to a known command
    pub opcode: u8,
    /// `u16` field to determine length of the body
    pub length: u16,
    /// `u64` randomly generated bytes that are used as a unique identifier
    pub nonce: u64,
}

impl Header {
    pub fn parse(src: &mut BytesMut) -> IResult<&[u8], Header> {
        let (i, version) = parse_version(src)?;
        let (i, opcode) = parse_opcode(i)?;
        let (i, length) = parse_length(i)?;
        let (message, nonce) = parse_nonce(i)?;

        println!("message: {:?}", message);

        Ok((
            message,
            Header {
                version,
                opcode,
                length,
                nonce,
            },
        ))
    }
}

/// The protocol version, coupled with the direction of the frame.
///
/// The "direction" of the frame indicates whether the frame is a `Request` or
/// a `Response` variant. This will help keep track of traffic flow later.
#[derive(Debug, PartialEq)]
pub enum Version {
    Request,
    Response,
}

#[derive(Debug)]
pub struct Nonce {
    inner: [u8; 8],
}

impl Nonce {
    /// Constructs a new `Nonce` by generating a random array of bytes.
    pub fn new() -> Self {
        let mut dst = [0_u8; 8];
        thread_rng().fill_bytes(&mut dst);
        Self { inner: dst }
    }

    /// Get a reference to the inner data
    pub fn as_bytes(&self) -> &[u8] {
        &self.inner
    }
}

impl Default for Nonce {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug)]
pub struct Message {
    /// Variable length payload determined by the `length_field` value
    pub body: BytesMut,
}

#[cfg(test)]
mod tests {
    use super::*;
    use bytes::BufMut;

    #[test]
    fn header_can_be_decoded() {
        // Setup
        let data = b"\x01\x02\x00\x0C\x63\x6F\x6E\x64\x75\x69\x74\x33";
        let mut buf = BytesMut::with_capacity(12);
        let _nonce = Nonce::new();

        buf.put_slice(data);
        // Parse data from `Bytes` buffer into header while reading it into `dst`
        let header = Header::parse(&mut buf).unwrap();

        assert!(header.0.is_empty());
    }
}
